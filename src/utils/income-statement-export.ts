/**
 * Income Statement Export Utilities
 * 
 * Implements CSV, Excel, and PDF export functionality
 * Requirements: 8.1, 8.2, 8.3, 8.4
 */

import { format } from 'date-fns';
import type { 
  IncomeStatementEntry, 
  AggregatedEntry, 
  IncomeStatementFilters,
  AggregationLevel,
  PeriodTotals,
  ExportMetadata 
} from '@/types/income-statement';

// ============================================================================
// Types
// ============================================================================

export type ExportFormat = 'csv' | 'excel' | 'pdf';

interface ExportOptions {
  entries: IncomeStatementEntry[] | AggregatedEntry[];
  aggregationLevel: AggregationLevel;
  filters: IncomeStatementFilters;
  totals: PeriodTotals;
  generatedBy: string;
}

// ============================================================================
// Helper Functions
// ============================================================================

function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('fr-TN', {
    style: 'decimal',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
}

function isIndividualEntry(entry: IncomeStatementEntry | AggregatedEntry): entry is IncomeStatementEntry {
  return 'entry_number' in entry;
}

function createMetadata(options: ExportOptions): ExportMetadata {
  return {
    export_date: new Date().toISOString(),
    generated_by: options.generatedBy,
    filters: options.filters,
    date_range: {
      from: options.filters.date_from || null,
      to: options.filters.date_to || null,
    },
    aggregation_level: options.aggregationLevel,
    total_entries: options.entries.length,
  };
}

// ============================================================================
// CSV Export
// ============================================================================

export function exportToCSV(options: ExportOptions): void {
  const { entries, aggregationLevel, totals } = options;
  const metadata = createMetadata(options);
  const isIndividual = aggregationLevel === 'individual';

  // Build CSV content
  const rows: string[][] = [];

  // Metadata header
  rows.push(['Income Statement Export']);
  rows.push(['Export Date', format(new Date(metadata.export_date), 'PPP p')]);
  rows.push(['Generated By', metadata.generated_by]);
  rows.push(['Date Range', `${metadata.date_range.from || 'All'} to ${metadata.date_range.to || 'All'}`]);
  rows.push(['View', aggregationLevel.charAt(0).toUpperCase() + aggregationLevel.slice(1)]);
  rows.push(['Total Entries', metadata.total_entries.toString()]);
  rows.push([]);

  // Column headers
  if (isIndividual) {
    rows.push(['Date', 'Entry #', 'Description', 'Category', 'Type', 'Debit', 'Credit', 'Payment Method', 'Customer Type']);
  } else {
    rows.push(['Period', 'Category', 'Total Debit', 'Total Credit', 'Transaction Count']);
  }

  // Data rows
  for (const entry of entries) {
    if (isIndividualEntry(entry)) {
      rows.push([
        format(new Date(entry.transaction_date), 'yyyy-MM-dd'),
        entry.entry_number,
        `"${entry.description.replace(/"/g, '""')}"`,
        entry.account_category?.name || 'Uncategorized',
        entry.transaction_type,
        formatCurrency(Number(entry.debit_amount)),
        formatCurrency(Number(entry.credit_amount)),
        entry.payment_method || '',
        entry.customer_type || '',
      ]);
    } else {
      rows.push([
        entry.period_label,
        entry.account_category?.name || 'Uncategorized',
        formatCurrency(Number(entry.total_debit)),
        formatCurrency(Number(entry.total_credit)),
        entry.transaction_count.toString(),
      ]);
    }
  }

  // Totals
  rows.push([]);
  rows.push(['TOTALS']);
  rows.push(['Total Revenue', formatCurrency(totals.total_revenue)]);
  rows.push(['Total Expenses', formatCurrency(totals.total_expenses)]);
  rows.push(['Net Income', formatCurrency(totals.net_income)]);

  // Category breakdown
  rows.push([]);
  rows.push(['CATEGORY BREAKDOWN']);
  for (const cat of totals.by_category) {
    rows.push([cat.category_name, formatCurrency(cat.total_debit), formatCurrency(cat.total_credit), formatCurrency(cat.net_amount)]);
  }

  // Convert to CSV string
  const csvContent = rows.map(row => row.join(',')).join('\n');

  // Download
  downloadFile(csvContent, `income-statement-${format(new Date(), 'yyyy-MM-dd')}.csv`, 'text/csv');
}

// ============================================================================
// Excel Export (using CSV with Excel-compatible format)
// ============================================================================

export function exportToExcel(options: ExportOptions): void {
  const { entries, aggregationLevel, totals } = options;
  const metadata = createMetadata(options);
  const isIndividual = aggregationLevel === 'individual';

  // Build Excel-compatible CSV with formulas
  const rows: string[][] = [];

  // Metadata header
  rows.push(['Income Statement Export']);
  rows.push(['Export Date', format(new Date(metadata.export_date), 'PPP p')]);
  rows.push(['Generated By', metadata.generated_by]);
  rows.push(['Date Range', `${metadata.date_range.from || 'All'} to ${metadata.date_range.to || 'All'}`]);
  rows.push(['View', aggregationLevel.charAt(0).toUpperCase() + aggregationLevel.slice(1)]);
  rows.push([]);

  // Column headers
  const headerRow = isIndividual 
    ? ['Date', 'Entry #', 'Description', 'Category', 'Type', 'Debit', 'Credit']
    : ['Period', 'Category', 'Total Debit', 'Total Credit', 'Count'];
  rows.push(headerRow);

  const dataStartRow = rows.length + 1;

  // Data rows
  for (const entry of entries) {
    if (isIndividualEntry(entry)) {
      rows.push([
        format(new Date(entry.transaction_date), 'yyyy-MM-dd'),
        entry.entry_number,
        `"${entry.description.replace(/"/g, '""')}"`,
        entry.account_category?.name || 'Uncategorized',
        entry.transaction_type,
        Number(entry.debit_amount).toString(),
        Number(entry.credit_amount).toString(),
      ]);
    } else {
      rows.push([
        entry.period_label,
        entry.account_category?.name || 'Uncategorized',
        Number(entry.total_debit).toString(),
        Number(entry.total_credit).toString(),
        entry.transaction_count.toString(),
      ]);
    }
  }

  const dataEndRow = rows.length;

  // Add formulas for totals
  rows.push([]);
  rows.push(['TOTALS']);
  
  if (isIndividual) {
    rows.push(['Total Debit', `=SUM(F${dataStartRow}:F${dataEndRow})`]);
    rows.push(['Total Credit', `=SUM(G${dataStartRow}:G${dataEndRow})`]);
    rows.push(['Net Income', `=SUM(G${dataStartRow}:G${dataEndRow})-SUM(F${dataStartRow}:F${dataEndRow})`]);
  } else {
    rows.push(['Total Debit', `=SUM(C${dataStartRow}:C${dataEndRow})`]);
    rows.push(['Total Credit', `=SUM(D${dataStartRow}:D${dataEndRow})`]);
    rows.push(['Net Income', `=SUM(D${dataStartRow}:D${dataEndRow})-SUM(C${dataStartRow}:C${dataEndRow})`]);
  }

  // Convert to CSV string
  const csvContent = rows.map(row => row.join('\t')).join('\n');

  // Download as .xls (Excel will open tab-separated values)
  downloadFile(csvContent, `income-statement-${format(new Date(), 'yyyy-MM-dd')}.xls`, 'application/vnd.ms-excel');
}

// ============================================================================
// PDF Export (generates HTML that can be printed to PDF)
// ============================================================================

export function exportToPDF(options: ExportOptions): void {
  const { entries, aggregationLevel, totals } = options;
  const metadata = createMetadata(options);
  const isIndividual = aggregationLevel === 'individual';

  // Build HTML content
  const html = `
<!DOCTYPE html>
<html>
<head>
  <title>Income Statement - ${format(new Date(), 'yyyy-MM-dd')}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; font-size: 12px; }
    h1 { color: #333; font-size: 18px; margin-bottom: 10px; }
    .metadata { margin-bottom: 20px; color: #666; }
    .metadata p { margin: 2px 0; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f5f5f5; font-weight: bold; }
    .debit { color: #dc2626; }
    .credit { color: #16a34a; }
    .totals { margin-top: 20px; }
    .totals h2 { font-size: 14px; margin-bottom: 10px; }
    .totals-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
    .total-card { border: 1px solid #ddd; padding: 15px; border-radius: 4px; }
    .total-card h3 { margin: 0 0 5px 0; font-size: 12px; color: #666; }
    .total-card .value { font-size: 18px; font-weight: bold; }
    .category-breakdown { margin-top: 20px; }
    .category-breakdown h2 { font-size: 14px; margin-bottom: 10px; }
    @media print {
      body { margin: 0; }
      .no-print { display: none; }
    }
  </style>
</head>
<body>
  <h1>Income Statement Report</h1>
  
  <div class="metadata">
    <p><strong>Export Date:</strong> ${format(new Date(metadata.export_date), 'PPP p')}</p>
    <p><strong>Generated By:</strong> ${metadata.generated_by}</p>
    <p><strong>Date Range:</strong> ${metadata.date_range.from || 'All'} to ${metadata.date_range.to || 'All'}</p>
    <p><strong>View:</strong> ${aggregationLevel.charAt(0).toUpperCase() + aggregationLevel.slice(1)}</p>
    <p><strong>Total Entries:</strong> ${metadata.total_entries}</p>
  </div>

  <table>
    <thead>
      <tr>
        ${isIndividual 
          ? '<th>Date</th><th>Entry #</th><th>Description</th><th>Category</th><th>Debit</th><th>Credit</th>'
          : '<th>Period</th><th>Category</th><th>Total Debit</th><th>Total Credit</th><th>Count</th>'
        }
      </tr>
    </thead>
    <tbody>
      ${entries.map(entry => {
        if (isIndividualEntry(entry)) {
          return `
            <tr>
              <td>${format(new Date(entry.transaction_date), 'MMM dd, yyyy')}</td>
              <td>${entry.entry_number}</td>
              <td>${entry.description}</td>
              <td>${entry.account_category?.name || 'Uncategorized'}</td>
              <td class="debit">${Number(entry.debit_amount) > 0 ? formatCurrency(Number(entry.debit_amount)) : '-'}</td>
              <td class="credit">${Number(entry.credit_amount) > 0 ? formatCurrency(Number(entry.credit_amount)) : '-'}</td>
            </tr>
          `;
        } else {
          return `
            <tr>
              <td>${entry.period_label}</td>
              <td>${entry.account_category?.name || 'Uncategorized'}</td>
              <td class="debit">${formatCurrency(Number(entry.total_debit))}</td>
              <td class="credit">${formatCurrency(Number(entry.total_credit))}</td>
              <td>${entry.transaction_count}</td>
            </tr>
          `;
        }
      }).join('')}
    </tbody>
  </table>

  <div class="totals">
    <h2>Summary</h2>
    <div class="totals-grid">
      <div class="total-card">
        <h3>Total Revenue</h3>
        <div class="value credit">${formatCurrency(totals.total_revenue)} TND</div>
      </div>
      <div class="total-card">
        <h3>Total Expenses</h3>
        <div class="value debit">${formatCurrency(totals.total_expenses)} TND</div>
      </div>
      <div class="total-card">
        <h3>Net Income</h3>
        <div class="value ${totals.net_income >= 0 ? 'credit' : 'debit'}">${formatCurrency(totals.net_income)} TND</div>
      </div>
    </div>
  </div>

  <div class="category-breakdown">
    <h2>Category Breakdown</h2>
    <table>
      <thead>
        <tr>
          <th>Category</th>
          <th>Debit</th>
          <th>Credit</th>
          <th>Net</th>
        </tr>
      </thead>
      <tbody>
        ${totals.by_category.map(cat => `
          <tr>
            <td>${cat.category_name}</td>
            <td class="debit">${formatCurrency(cat.total_debit)}</td>
            <td class="credit">${formatCurrency(cat.total_credit)}</td>
            <td class="${cat.net_amount >= 0 ? 'credit' : 'debit'}">${formatCurrency(cat.net_amount)}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
  </div>

  <script>
    window.onload = function() {
      window.print();
    };
  </script>
</body>
</html>
  `;

  // Open in new window for printing
  const printWindow = window.open('', '_blank');
  if (printWindow) {
    printWindow.document.write(html);
    printWindow.document.close();
  }
}

// ============================================================================
// Download Helper
// ============================================================================

function downloadFile(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// ============================================================================
// Main Export Function
// ============================================================================

export function exportIncomeStatement(format: ExportFormat, options: ExportOptions): void {
  switch (format) {
    case 'csv':
      exportToCSV(options);
      break;
    case 'excel':
      exportToExcel(options);
      break;
    case 'pdf':
      exportToPDF(options);
      break;
  }
}
